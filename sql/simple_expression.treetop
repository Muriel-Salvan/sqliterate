require 'sql/space'
require 'sql/identifier'
require 'sql/keywords'
require 'sql/string'

module Sql
  grammar Expression
    include Space
    include Identifier
    include Keywords
    include String

    rule scalar_expression
      gen_expression
    end

    rule gen_expression
      gen_value r:( space gen_operator space gen_value )* {
        def value
          [gen_value.value] + r.elements.flat_map do |e|
            [e.gen_operator.name, e.gen_value.value]
          end
        end
      }
      /
      gen_operator gen_expression {
        def value
          [gen_operator.name] + gen_expression.value
        end
      }
    end

    rule gen_operator
      ( '*' / '/' / '+' / '-'
      / '=' / '<' / '>'
      / '~' / '!' / '@' / '#' / '%'
      / '^' / '&' / '|' / '?'
      / and_kw / or_kw ) {
        def name
          text_value.to_sym
        end
      }
    end

    rule gen_value
      literal_value
      /
      function_call
      /
      field_value r:( space '[' space range_expression space ']' )+ {
        def value
          [:s, field_value.value] + r.elements.map do |e|
            e.range_expression.value
          end
        end
      }
      /
      field_value
    end

    rule function_call
      function_name space function_params {
        def value
          [function_name.name] + function_params.value
        end
      }
    end

    rule function_name
      qualified_name / identifier
    end

    rule function_params
      '(' space ')' {
        def value
          []
        end
      }
      /
      '(' space gen_expression space r:(',' space gen_expression space)* ')' {
        def value
          [gen_expression.value] + r.elements.map { |e| e.gen_expression.value }
        end
      }
    end

    rule range_expression
      b:gen_expression space ':' space e:gen_expression {
        def value
          [:r, b.value, e.value]
        end
      }
      /
      gen_expression
    end

    rule field_value
      terminal_value space '.' space identifier {
        def value
          [:f, terminal_value.value, identifier.name]
        end
      }
      /
      terminal_value
    end

    rule terminal_value
      '(' space gen_expression space ')' {
        def value
          gen_expression.value
        end
      }
      /
      positional_param
      /
      identifier {
        def value
          name
        end
      }
    end

    rule literal_value
      multi_string / numeric_literal / boolean_literal
    end

    rule positional_param
      '$' digits {
        def value
          [:p, digits.value]
        end
      }
    end

    rule numeric_literal
      decimal_literal numeric_exponent {
        def value
          decimal_literal.value * (10 ** numeric_exponent.value)
        end
      }
      /
      decimal_literal
    end

    rule decimal_literal
      ( digits ( '.' digits? )? / '.' digits ) {
        def value
          text_value.to_f
        end
      }
    end

    rule numeric_exponent
      'e' s:( '+' / '-' )? digits {
        def value
          digits.value * ( s.text_value == '-' ? -1 : 1 )
        end
      }
    end

    rule digits
      [0-9]+ { def value; text_value.to_i end }
    end

    rule boolean_literal
      true_kw { def value; true end }
      /
      false_kw { def value; false end }
    end
  end
end
